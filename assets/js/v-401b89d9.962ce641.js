"use strict";(self.webpackChunkkevinBlog=self.webpackChunkkevinBlog||[]).push([[530],{623:(e,l,t)=>{t.r(l),t.d(l,{data:()=>r});const r={key:"v-401b89d9",path:"/pages/frame/vue/vue%E5%8E%9F%E7%90%86/vue%E5%8E%9F%E7%90%86.html",title:"",lang:"zh-cn",frontmatter:{},excerpt:"",headers:[{level:3,title:"响应式数据的实现流程",slug:"响应式数据的实现流程",children:[]},{level:3,title:"vue收集依赖，什么是依赖？",slug:"vue收集依赖-什么是依赖",children:[]},{level:2,title:"明明是watcher收集依赖,应该是watcher收集数据,怎么成了数据的dep收集watcher了呢？",slug:"明明是watcher收集依赖-应该是watcher收集数据-怎么成了数据的dep收集watcher了呢",children:[{level:3,title:"为什么数据劫持不能监听数组？",slug:"为什么数据劫持不能监听数组",children:[]},{level:3,title:"vue数组响应式的实现？",slug:"vue数组响应式的实现",children:[]},{level:3,title:"依赖收集过程：",slug:"依赖收集过程",children:[]},{level:3,title:"双向绑定的原理描述和总结",slug:"双向绑定的原理描述和总结",children:[]}]},{level:2,title:"computed 的实现原理",slug:"computed-的实现原理",children:[]}],filePathRelative:"pages/frame/vue/vue原理/vue原理.md",git:{updatedTime:1662212859e3,contributors:[{name:"kevinZzzzzzzz",email:"jie736805161@qq.com",commits:1}]}}},187:(e,l,t)=>{t.r(l),t.d(l,{default:()=>$});var r=t(6252),n=t(394),u=t(986),a=t(2191),c=t(3917),d=t(4903);const h=(0,r._)("h3",{id:"响应式数据的实现流程",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#响应式数据的实现流程","aria-hidden":"true"},"#"),(0,r.Uk)(" 响应式数据的实现流程")],-1),p=(0,r._)("p",null,[(0,r._)("img",{src:n,alt:"截屏2021-08-24"})],-1),i=(0,r._)("h3",{id:"vue收集依赖-什么是依赖",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#vue收集依赖-什么是依赖","aria-hidden":"true"},"#"),(0,r.Uk)(" vue收集依赖，什么是依赖？")],-1),s=(0,r._)("p",null,"答：需要用到数据的地方就叫依赖，在getter()中收集依赖，在setter()中触发依赖。有了依赖，就可以在数据变化时，只更新与这个数据有关的DOM结构，不至于说任何一个数据变化，都会导致整个页面重新渲染，代价太大。",-1),o=(0,r._)("h2",{id:"明明是watcher收集依赖-应该是watcher收集数据-怎么成了数据的dep收集watcher了呢",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#明明是watcher收集依赖-应该是watcher收集数据-怎么成了数据的dep收集watcher了呢","aria-hidden":"true"},"#"),(0,r.Uk)(" 明明是watcher收集依赖,应该是watcher收集数据,怎么成了数据的dep收集watcher了呢？")],-1),_=(0,r._)("p",null,"答：Dep的作用是收集观察者以及当数据发生变化的时候通知观察者watcher去更新。（在每次observe的时候都会给每个实例添加一个属于自己的dep）",-1),g=(0,r._)("p",null,"watcher观察者相当于中介，为的是通知组件更新",-1),m=(0,r._)("p",null,[(0,r._)("img",{src:u,alt:"哈哈哈哈"})],-1),k=(0,r._)("p",null,[(0,r._)("img",{src:a,alt:"呵呵呵"})],-1),w=(0,r._)("p",null,[(0,r._)("img",{src:c,alt:"呵呵呵"})],-1),v=(0,r._)("hr",null,null,-1),U=(0,r._)("h3",{id:"为什么数据劫持不能监听数组",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#为什么数据劫持不能监听数组","aria-hidden":"true"},"#"),(0,r.Uk)(" 为什么数据劫持不能监听数组？")],-1),f=(0,r._)("p",null,"答：其实本身是可以的，只是尤大觉得实现的成本太高。毕竟数组是有序的结构，每次新增或者删除某项都会导致每个元素的位置移动，这会触发getter和setter函数，导致依赖发生变化。",-1),b=(0,r._)("ul",null,[(0,r._)("li",null,[(0,r.Uk)("直接"),(0,r._)("code",null,"vm.items[indexOfItem] = newValue"),(0,r.Uk)("是无法检测到的，length 属性不能监听因为无法触发 obj 的 get 方法。")])],-1),x=(0,r._)("h3",{id:"vue数组响应式的实现",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#vue数组响应式的实现","aria-hidden":"true"},"#"),(0,r.Uk)(),(0,r._)("strong",null,"vue数组响应式的实现？")],-1),y=(0,r._)("p",null,[(0,r.Uk)("vue改写了数组的7个方法： push、pop、shift、unshift、splice、sort、reverse。这7个方法都是定义在"),(0,r._)("strong",null,"Array.prototype")],-1),D=(0,r._)("p",null,[(0,r.Uk)("以"),(0,r._)("strong",null,"Array.prototype"),(0,r.Uk)("为原型创建了"),(0,r._)("strong",null,"arrayMethods"),(0,r.Uk)("对象，然后用"),(0,r._)("strong",null,"es6的Object.setPrototypeOf()"),(0,r.Uk)("（或者"),(0,r._)("code",null,"__proto__"),(0,r.Uk)("）强制改变所需要操作的数组的原型指向arrayMethods")],-1),z=(0,r._)("p",null,[(0,r._)("img",{src:d,alt:"呵呵呵"})],-1),W=(0,r._)("hr",null,null,-1),O=(0,r._)("blockquote",null,[(0,r._)("p",null,"每个 Vue 组件都有对应的一个 Watcher 实例，如果一个属性在不同组件上都使用到，将把不同组件的 Watcher 都添加到这个属性的 Dep 订阅器中，表示这些视图依赖这个对象属性，如果发生改变，这些视图都要进行更新。一个 Watcher 可能在多个 Dep 中同时存在。")],-1),j=(0,r._)("h3",{id:"依赖收集过程",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#依赖收集过程","aria-hidden":"true"},"#"),(0,r.Uk)(" 依赖收集过程：")],-1),V=(0,r._)("p",null,[(0,r._)("strong",null,"Vue模版编译原理")],-1),A=(0,r._)("blockquote",null,[(0,r._)("p",null,[(0,r._)("strong",null,"编译阶段compile"),(0,r.Uk)(" ⬇️"),(0,r._)("strong",null,"挂载前的准备工作：")]),(0,r._)("ul",null,[(0,r._)("li",null,[(0,r._)("p",null,[(0,r.Uk)("查看是否有"),(0,r._)("code",null,"<template>"),(0,r.Uk)("(模板)，内部执行compile函数，解析成"),(0,r._)("code",null,"render function"),(0,r.Uk)("，")]),(0,r._)("ul",null,[(0,r._)("li",null,[(0,r._)("strong",null,"compile函数"),(0,r.Uk)("，包括parse（解析template为"),(0,r._)("strong",null,"AST"),(0,r.Uk)("抽象语法树），optimize（标记静态节点，在diff算法执行过程中会跳过这些静态节点，优化点），generate（"),(0,r._)("strong",null,"AST"),(0,r.Uk)("抽象语法树 --\x3e render function ）三个阶段。 "),(0,r._)("ul",null,[(0,r._)("li",null,[(0,r._)("strong",null,"AST语法树"),(0,r.Uk)("：一种用js对象形式描述整个模版template。")]),(0,r._)("li",null,"解析阶段：使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子函数进行处理"),(0,r._)("li",null,"优化阶段，模板中有些内容是不需要关联data数据的，首次渲染完就不会再变化的——静态节点，这些内容需要将他们进行标记，等下下次更新模板执行diff算法时就会跳过它们。"),(0,r._)("li",null,"转换阶段：将解析并且优化后的AST语法树转换为可执行的代码render function。")])])])]),(0,r._)("li",null,[(0,r._)("p",null,[(0,r.Uk)("模板编译执行"),(0,r._)("code",null,"render function"),(0,r.Uk)("渲染出虚拟dom，**此时还没有生成真实 DOM，因为还没真正挂载。**然后读取模板上插值表达式的值，触发getter函数，执行收集依赖，将订阅者Watcher添加进Dep中。")]),(0,r._)("p",null,"（当插值表达式的值发生改变时，会触发setter函数，通知Dep中对应的订阅者Watcher，执行update函数重新渲染页面）")])])],-1),E=(0,r._)("p",null,"在执行compile函数后，template会被编译成render函数，然后在执行render函数的过程中每个组件会实例化一个watcher对象，实例化工程中就会触发属性的getter函数，从而将这个数据所对应的watcher对象收集各自的依赖管理者dep当中。render 函数的结果便是重新生成 vnode，当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。",-1),q=(0,r._)("blockquote",null,[(0,r._)("p",null,"每个 Vue 组件都有对应的一个 Watcher 实例，如果一个属性在不同组件上都使用到，将把不同组件的 Watcher 都添加到这个属性的 Dep 订阅器中，表示这些视图依赖这个对象属性，如果发生改变，这些视图都要进行更新。一个 Watcher 可能在多个 Dep 中同时存在。")],-1),T=(0,r._)("hr",null,null,-1),M=(0,r._)("h3",{id:"双向绑定的原理描述和总结",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#双向绑定的原理描述和总结","aria-hidden":"true"},"#"),(0,r.Uk)(" 双向绑定的原理描述和总结")],-1),S=(0,r._)("p",null,"当创建 Vue 实例时,vue 初始化会遍历 data 选项的属性，通过Object.defineProperty 为属性添加 getter 和 setter来实现对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在调用时收集依赖,在属性被访问和修改时通知变化。",-1),P=(0,r._)("p",null,"每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中进行依赖收集（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。",-1),Z=(0,r._)("p",null,"一句话总结:",-1),B=(0,r._)("p",null,"vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调",-1),C=(0,r._)("hr",null,null,-1),F=(0,r._)("h2",{id:"computed-的实现原理",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#computed-的实现原理","aria-hidden":"true"},"#"),(0,r.Uk)(" computed 的实现原理")],-1),H=(0,r._)("h4",{id:"computed属性初始化",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#computed属性初始化","aria-hidden":"true"},"#"),(0,r.Uk)(" computed属性初始化")],-1),I=(0,r._)("p",null,"在vue初始化阶段中，当完成了对date属性的数据劫持过程后，也会初始化computed计算属性。",-1),R=(0,r._)("p",null,[(0,r.Uk)("computed 内部实现了一个惰性的 watcher,也就是 computed watcher,每个计算属性都会创建一个computed watcher。在执行render函数时会触发computed属性值的get方法，然后依次将这个计算属性的computed watcher和对应data属性的watcher实例添加到data属性的收集器dep内("),(0,r._)("strong",null,"注意订阅队列里的顺序，computed-watcher先，render-watcher后"),(0,r.Uk)(")。")],-1),Y=(0,r._)("p",null,"computed 本质是一个惰性求值的观察者。",-1),G=(0,r._)("p",null,[(0,r.Uk)("其内部通过 "),(0,r._)("code",null,"this.dirty "),(0,r.Uk)("属性标记计算属性是否需要重新求值: 当data属性变化时先调用computed-watcher的update函数然后将this.dirty 置为true，然后再调用render-watcher的update函数重新渲染。")],-1),J=(0,r._)("p",null,"当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,",-1),K=(0,r._)("p",null,"computed watcher 通过 this.dep.subs.length 判断有没有订阅者,",-1),L=(0,r._)("p",null,[(0,r.Uk)("有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 ("),(0,r._)("strong",null,"Vue 想确保不仅仅是计算属性依赖的值发生变化，而且是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。"),(0,r.Uk)(")")],-1),N=(0,r._)("hr",null,null,-1),Q=(0,r._)("p",null,[(0,r.Uk)("Watcher : 观察者对象 , 实例分为"),(0,r._)("code",null,"渲染 watcher"),(0,r.Uk)(" (render watcher),"),(0,r._)("code",null,"计算属性 watcher"),(0,r.Uk)(" (computed watcher),"),(0,r._)("code",null,"侦听器 watcher"),(0,r.Uk)("（user watcher）")],-1),X={},$=(0,t(3744).Z)(X,[["render",function(e,l){return(0,r.wg)(),(0,r.iD)(r.HY,null,[h,p,i,s,o,_,g,m,k,w,v,U,f,b,x,y,D,z,W,O,j,V,A,E,q,T,M,S,P,Z,B,C,F,H,I,R,Y,G,J,K,L,N,Q],64)}]])},3744:(e,l)=>{l.Z=(e,l)=>{const t=e.__vccOpts||e;for(const[e,r]of l)t[e]=r;return t}},394:(e,l,t)=>{e.exports=t.p+"assets/img/1.80de304b.png"},986:(e,l,t)=>{e.exports=t.p+"assets/img/2.a0eccde3.png"},2191:(e,l,t)=>{e.exports=t.p+"assets/img/3.09a44417.png"},3917:(e,l,t)=>{e.exports=t.p+"assets/img/7.e49cd543.png"},4903:(e,l,t)=>{e.exports=t.p+"assets/img/8.be6d6d0a.png"}}]);